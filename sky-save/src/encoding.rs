use crate::EncodingError;

fn decode_pmd(byte: u8) -> Result<char, EncodingError> {
    match byte {
        // 0x00 => 'END',
        // 0x01 => '$01',
        // 0x02 => '$02',
        // 0x03 => '$03',
        // 0x04 => '$04',
        // 0x05 => '$05',
        // 0x06 => '$06',
        // 0x07 => '$07',
        // 0x08 => '$08',
        // 0x09 => '$09',
        // 0x0A => '$0A',
        // 0x0B => '$0B',
        // 0x0C => '$0C',
        // 0x0D => '$0D',
        // 0x0E => '$0E',
        // 0x0F => '$0F',
        // 0x10 => '$10',
        // 0x11 => '$11',
        // 0x12 => '$12',
        // 0x13 => '$13',
        // 0x14 => '$14',
        // 0x15 => '$15',
        // 0x16 => '$16',
        // 0x17 => '$17',
        // 0x18 => '$18',
        // 0x19 => '$19',
        // 0x1A => '$1A',
        // 0x1B => '$1B',
        // 0x1C => '$1C',
        // 0x1D => '$1D',
        // 0x1E => '$1E',
        // 0x1F => '$1F',
        0x20 => Ok(' '),
        0x21 => Ok('!'),
        0x22 => Ok('\\'),
        0x23 => Ok('#'),
        0x24 => Ok('$'),
        0x25 => Ok('%'),
        0x26 => Ok('&'),
        0x27 => Ok('\''),
        0x28 => Ok('('),
        0x29 => Ok(')'),
        0x2A => Ok('*'),
        0x2B => Ok('+'),
        0x2C => Ok(','),
        0x2D => Ok('-'),
        0x2E => Ok('.'),
        0x2F => Ok('/'),
        0x30 => Ok('0'),
        0x31 => Ok('1'),
        0x32 => Ok('2'),
        0x33 => Ok('3'),
        0x34 => Ok('4'),
        0x35 => Ok('5'),
        0x36 => Ok('6'),
        0x37 => Ok('7'),
        0x38 => Ok('8'),
        0x39 => Ok('9'),
        0x3A => Ok(':'),
        0x3B => Ok(';'),
        0x3C => Ok('<'),
        0x3D => Ok('='),
        0x3E => Ok('>'),
        0x3F => Ok('?'),
        0x40 => Ok('@'),
        0x41 => Ok('A'),
        0x42 => Ok('B'),
        0x43 => Ok('C'),
        0x44 => Ok('D'),
        0x45 => Ok('E'),
        0x46 => Ok('F'),
        0x47 => Ok('G'),
        0x48 => Ok('H'),
        0x49 => Ok('I'),
        0x4A => Ok('J'),
        0x4B => Ok('K'),
        0x4C => Ok('L'),
        0x4D => Ok('M'),
        0x4E => Ok('N'),
        0x4F => Ok('O'),
        0x50 => Ok('P'),
        0x51 => Ok('Q'),
        0x52 => Ok('R'),
        0x53 => Ok('S'),
        0x54 => Ok('T'),
        0x55 => Ok('U'),
        0x56 => Ok('V'),
        0x57 => Ok('W'),
        0x58 => Ok('X'),
        0x59 => Ok('Y'),
        0x5A => Ok('Z'),
        // 0x5B => '$5B',
        0x5C => Ok('\\'),
        0x5D => Ok(']'),
        0x5E => Ok('^'),
        0x5F => Ok('_'),
        0x60 => Ok('`'),
        0x61 => Ok('a'),
        0x62 => Ok('b'),
        0x63 => Ok('c'),
        0x64 => Ok('d'),
        0x65 => Ok('e'),
        0x66 => Ok('f'),
        0x67 => Ok('g'),
        0x68 => Ok('h'),
        0x69 => Ok('i'),
        0x6A => Ok('j'),
        0x6B => Ok('k'),
        0x6C => Ok('l'),
        0x6D => Ok('m'),
        0x6E => Ok('n'),
        0x6F => Ok('o'),
        0x70 => Ok('p'),
        0x71 => Ok('q'),
        0x72 => Ok('r'),
        0x73 => Ok('s'),
        0x74 => Ok('t'),
        0x75 => Ok('u'),
        0x76 => Ok('v'),
        0x77 => Ok('w'),
        0x78 => Ok('x'),
        0x79 => Ok('y'),
        0x7A => Ok('z'),
        0x7B => Ok('{'),
        0x7C => Ok('|'),
        0x7D => Ok('}'),
        // 0x7E => '$7E',
        // 0x7F => '$7F',
        0x80 => Ok('€'),
        // 0x81 => '$81',
        // 0x82 => '$82',
        // 0x83 => '$83',
        // 0x84 => '$84',
        0x85 => Ok('…'),
        0x86 => Ok('†'),
        // 0x87 => '$87',
        0x88 => Ok('ˆ'),
        0x89 => Ok('‰'),
        0x8A => Ok('Š'),
        0x8B => Ok('‹'),
        0x8C => Ok('Œ'),
        // 0x8D => '[e]',
        0x8E => Ok('Ž'),
        // 0x8F => '[è]',
        0x90 => Ok('•'),
        0x91 => Ok('‘'),
        0x92 => Ok('’'),
        0x93 => Ok('“'),
        0x94 => Ok('”'),
        0x95 => Ok('•'),
        // 0x96 => '[er]',
        // 0x97 => '[re]',
        0x98 => Ok('~'),
        0x99 => Ok('™'),
        0x9A => Ok('š'),
        0x9B => Ok('›'),
        0x9C => Ok('œ'),
        0x9D => Ok('•'),
        0x9E => Ok('ž'),
        0x9F => Ok('Ÿ'),
        0xA0 => Ok(' '),
        0xA1 => Ok('¡'),
        0xA2 => Ok('¢'),
        0xA3 => Ok('£'),
        0xA4 => Ok('¤'),
        0xA5 => Ok('¥'),
        0xA6 => Ok('¦'),
        0xA7 => Ok('§'),
        0xA8 => Ok('¨'),
        0xA9 => Ok('©'),
        0xAA => Ok('ª'),
        0xAB => Ok('«'),
        0xAC => Ok('¬'),
        0xAD => Ok('\u{00AD}'), // clippy doesn't like '\u{00AD}'
        0xAE => Ok('®'),
        0xAF => Ok('¯'),
        0xB0 => Ok('°'),
        0xB1 => Ok('±'),
        0xB2 => Ok('²'),
        0xB3 => Ok('³'),
        0xB4 => Ok('´'),
        0xB5 => Ok('µ'),
        0xB6 => Ok('¶'),
        0xB7 => Ok('„'),
        0xB8 => Ok('‚'),
        0xB9 => Ok('¹'),
        0xBA => Ok('º'),
        0xBB => Ok('»'),
        0xBC => Ok('←'),
        0xBD => Ok('♂'),
        0xBE => Ok('♀'),
        0xBF => Ok('¿'),
        0xC0 => Ok('À'),
        0xC1 => Ok('Á'),
        0xC2 => Ok('Â'),
        0xC3 => Ok('Ã'),
        0xC4 => Ok('Ä'),
        0xC5 => Ok('Å'),
        0xC6 => Ok('Æ'),
        0xC7 => Ok('Ç'),
        0xC8 => Ok('È'),
        0xC9 => Ok('É'),
        0xCA => Ok('Ê'),
        0xCB => Ok('Ë'),
        0xCC => Ok('Ì'),
        0xCD => Ok('Í'),
        0xCE => Ok('Î'),
        0xCF => Ok('Ï'),
        0xD0 => Ok('Ð'),
        0xD1 => Ok('Ñ'),
        0xD2 => Ok('Ò'),
        0xD3 => Ok('Ó'),
        0xD4 => Ok('Ô'),
        0xD5 => Ok('Õ'),
        0xD6 => Ok('Ö'),
        0xD7 => Ok('×'),
        0xD8 => Ok('Ø'),
        0xD9 => Ok('Ù'),
        0xDA => Ok('Ú'),
        0xDB => Ok('Û'),
        0xDC => Ok('Ü'),
        0xDD => Ok('Ý'),
        0xDE => Ok('Þ'),
        0xDF => Ok('ß'),
        0xE0 => Ok('à'),
        0xE1 => Ok('á'),
        0xE2 => Ok('â'),
        0xE3 => Ok('ã'),
        0xE4 => Ok('ä'),
        0xE5 => Ok('å'),
        0xE6 => Ok('æ'),
        0xE7 => Ok('ç'),
        0xE8 => Ok('è'),
        0xE9 => Ok('é'),
        0xEA => Ok('ê'),
        0xEB => Ok('ë'),
        0xEC => Ok('ì'),
        0xED => Ok('í'),
        0xEE => Ok('î'),
        0xEF => Ok('ï'),
        0xF0 => Ok('ð'),
        0xF1 => Ok('ñ'),
        0xF2 => Ok('ò'),
        0xF3 => Ok('ó'),
        0xF4 => Ok('ô'),
        0xF5 => Ok('õ'),
        0xF6 => Ok('ö'),
        0xF7 => Ok('÷'),
        0xF8 => Ok('ø'),
        0xF9 => Ok('ù'),
        0xFA => Ok('ú'),
        0xFB => Ok('û'),
        0xFC => Ok('ü'),
        0xFD => Ok('ý'),
        0xFE => Ok('þ'),
        0xFF => Ok('ÿ'),
        _ => Err(EncodingError::InvalidCharacter(byte)),
    }
}

/// Converts a PMD encoded byte to a Unicode character using a predefined table.
/// Returns an error if the byte is not a valid PMD character.
/// Every PMD character is a valid Unicode character.
pub fn pmd_to_char(byte: u8) -> Result<char, EncodingError> {
    decode_pmd(byte)
}

/// Converts a slice of PMD encoded bytes to a `String`, running `pmd_to_char` on each byte.
/// Returns an error if any of the bytes are not valid PMD characters.
pub fn pmd_to_string(bytes: &[u8]) -> Result<String, EncodingError> {
    bytes
        .iter()
        .filter(|&b| *b != 0)
        .map(|&b| decode_pmd(b))
        .collect()
}
